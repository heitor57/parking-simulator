#+TITLE: Algoritmos e Estrutura de Dados III (2019-1)
#+SUBTITLE: Trabalho Prático 1 
#+AUTHOR: Heitor Lourenço Werneck
#+EMAIL: heitorwerneck@hotmail.com
#+LANGUAGE: pt
#+OPTIONS: ^:nil email:nil author:nil
#+LATEX_HEADER: \author{Heitor Lourenço Werneck \\{\href{mailto:heitorwerneck@hotmail.com}{heitorwerneck@hotmail.com}}}
#+LATEX_HEADER: \usepackage[AUTO]{babel}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage[binary-units=true]{siunitx}
#+LATEX_HEADER: \usepackage[top=0.5cm,bottom=1.2cm,left=2cm,right=2cm]{geometry}

#+LATEX_HEADER: \usepackage{mdframed}
#+LATEX_HEADER: \usepackage{algorithm}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{algpseudocode}
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usetikzlibrary{shapes,arrows}
#+LATEX_HEADER: \usepackage{mathtools}
#+latex_class_options: [11pt]

#+PROPERTY: header-args :eval no
#+BEGIN_EXPORT latex
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\BeforeBeginEnvironment{minted}{\begin{mdframed}[backgroundcolor=bg]}
\AfterEndEnvironment{minted}{\end{mdframed}}
\numberwithin{equation}{section}
\algnewcommand{\IfThenElse}[3]{% \IfThenElse{<if>}{<then>}{<else>}
  \State \algorithmicif\ #1\ \algorithmicthen\ #2\ \algorithmicelse\ #3}

% Define block styles
\tikzstyle{decision} = [diamond, draw, fill=blue!20, 
    text width=4.5em, text badly centered, node distance=3cm, inner sep=0pt]
\tikzstyle{block} = [rectangle, draw, fill=blue!20, 
    text width=5em, text centered, rounded corners, minimum height=4em]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{cloud} = [ellipse, draw, fill=red!20, 
    text width=5em, text centered, rounded corners, minimum height=2em]
%\tikzstyle{cloud} = [draw, ellipse,fill=red!20, node distance=3.5cm,
%    minimum height=2em]


\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  frame=single,
  breaklines=true,
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
}
#+END_EXPORT
\newpage
* Introdução
  O trabalho a ser apresentado consiste na resolução do problema de planejamento de manobras tendo em vista maximizar a ocupação do estacionamento e minimizar o tempo de espera dos clientes para sair do estacionamento. Como o problema parece ser complexo, inicialmente será abordado uma parte simples da solução. Uma breve descrição do programa:
- O estacionamento é quadrado e tem dimensões 6 por 6.
- Os carros não fazem curva.
- As dimensões são identificadas de X1 a X6 e de Y1 a Y6.
- O estacionamento comporta dois tipos de veículos: carros e caminhões.
- Carros têm dimensão 2 por 1 e os caminhões têm dimensão 3 por 1.
- O objetivo é mover um carro específico, que chamaremos Z para a saída do estacionamento.
- O programa deve receber como entrada a configuração inicial do estacionamento e um conjunto de manobras.
- Deve responder se teve sucesso ou não em retirar o carro Z.

Entrada do programa:
- Arquivo de configuração inicial no qual informa os veículos e suas posições. Os veículos podem estar posicionados paralelo ao eixo X ou ao eixo Y. Cada linha informa sobre um veículo: identificador, tamanho, direção e posição. 
- Arquivo de manobras no qual informa os movimentos dos veículos. Cada movimento indica o veículo, a dimensão onde o movimento ocorre e a amplitude do movimento.

Erros que devem ser alertados:
- Alertar para configurações físicas impossíveis (isto é, dois veículos ocupando a mesma posição).
- Manobras inviáveis (colisões entre veículos e com os muros
do estacionamento).

Logo será criado um simulador de um estacionamento simplificado. Para resolver esse problema foi utilizado estruturas de dados com boa complexidade assintótica para casos gerais.

** Uma visão geral sobre a solução

#+BEGIN_EXPORT latex
\begin{center}
\begin{tikzpicture}[node distance = 2.8cm, auto]
    % Place nodes, main nodes
    \node [block] (argumentos) {Execução do programa};
    \node [block, below of=argumentos] (leituraarg) {Le os argumentos passados e abre os arquivos};
    \node [cloud, left of=leituraarg] (arqentradac) {Arquivo de configuração inicial};
    \node [cloud, right of=leituraarg] (arqentradam) {Arquivo de manobras};
    \node [block, below of=leituraarg,xshift=-2cm] (varini) {Inicializa as variaveis};
    \node [block, below of=varini] (containi) {Começa a contar o tempo};
    \node [block, below of=containi] (estacionamento) {Cria o estacionamento};
    \node [block, below of=estacionamento,xshift=-2cm] (manobras) {Aplica manobras};

    \node [block, below of=manobras,xshift=-2cm] (contapara) {Para de contar o tempo};

    \node [cloud, left of=contapara] (contaimprime) {Imprime o tempo};
    \node [block, below of=contapara] (varfim) {Desaloca variaveis};
    % node erros
    \node [cloud, below of=leituraarg,xshift=2cm] (erro1) {Erro na abertura};

    \node [cloud, below of=estacionamento,xshift=2cm] (erro2) {Erro na configuração do estacionamento};
    \node [cloud, below of=manobras,xshift=2cm] (erro3) {Erro na aplicação das manobras};

    % Draw edges
    \path [line,dashed] (argumentos) -- (leituraarg) node [midway, yshift= -0.1cm ,above] (TextNode) {Argumentos};
    \path [line,dashed] (arqentradac) -- (leituraarg);
    \path [line,dashed] (arqentradam) -- (leituraarg);
    \path [line,dashed] (leituraarg) -- (varini) node [midway, yshift= -0.1cm ,above] (TextNode) {Sucesso};
    \path [line,dashed] (varini) -- (containi);
    \path [line,dashed] (containi) -- (estacionamento);
    \path [line,dashed] (estacionamento) -- (manobras) node [midway, yshift= -0.1cm ,above] (TextNode) {Sucesso};
    \path [line,dashed] (estacionamento) -- (erro2) node [midway, yshift= -0.1cm ,above] (TextNode) {Falha};
    \path [line,dashed] (leituraarg) -- (erro1) node [midway, yshift= -0.1cm ,above] (TextNode) {Falha};
    \path [line,dashed] (manobras) -- (erro3) node [midway, yshift= -0.1cm ,above] (TextNode) {Falha};
    \path [line,dashed] (manobras) -- (contapara) node [midway, yshift= -0.1cm ,above] (TextNode) {Sucesso};
    \path [line,dashed] (erro3) -- (contapara);
    \path [line,dashed] (contapara) -- (contaimprime);
    \path [line,dashed] (contapara) -- (varfim);
    \path [line,dashed] (erro2) to[out=-20,in=-70] (varfim);
\end{tikzpicture}
\end{center}
#+END_EXPORT

\newpage
* Módulos
** Estruturas de dados
  As estruturas de dados são de extrema importância para resolução do problema, elas irão ter grande peso na complexidade do programa e no seu funcionamento.
*** Tabela de dispersão
   A tabela de dispersão cite:hashingusp foi utilizada pois visto que há referencia aos nomes respectivos dos veículos constantemente no arquivo de manobras, logo uma tabela de dispersão comum garante complexidade de tempo sobre as operações de inserção e busca de $\Theta(1)$ e $O(n)$(Ao longo do documento será utilizado espalhamento comum para o espalhamento com complexidade $O(n)$). É interessante lembrar que existe o espalhamento perfeito (/perfect hashing/) cite:cormen09_introd que também foi implementado nesse trabalho que garante complexidade de tempo $O(1)$ para operações de inserção e busca, porém a complexidade de espaço no pior caso é $\Omega(n)$. 

   A tabela de dispersão normal utilizou a função de espalhamento modular com sondagem linear.
   
   Na análise de resultados será possível ver quão diferente o espalhamento perfeito pode ser no tempo de execução.

   O espalhamento perfeito foi utilizado aproveitando-se do fato que os identificadores dos veículos são caracteres, e existem 256 caracteres diferentes, ou seja um numero fixo de entradas possíveis.
   
   A tabela de dispersão principal contem 16 outras tabelas podendo conter 16 objetos, todas elas não alocadas para uma economia de blocos de caracteres não utilizados. 

#+BEGIN_EXPORT latex
\begin{equation}\label{eq:HashSize}
\begin{aligned}
\underbrace{obj.label}_{\parbox{1.75cm}{ Rotulo do objeto}} \in \{x : x \in \mathbb{N} \land (0 \leq x \leq 255)\}\\
ASCII\_SIZE = 256\\
HashSize = \frac{ASCII\_SIZE}{16}\\
HashSize = 16\\
\end{aligned}
\end{equation}
#+END_EXPORT

Um detalhe de implementação interessante e que na criação da tabela de dispersão com espalhamento perfeito já é alocado os blocos de caracteres previstos como sendo os mais utilizados, que são os blocos que contem A e Z.

#+BEGIN_SRC C
    perf_hash->hashs[hash_division('A',TABLE_SIZE)]= new_hash(TABLE_SIZE);
    perf_hash->hashs[hash_division('Z',TABLE_SIZE)]= new_hash(TABLE_SIZE);
#+END_SRC

#+BEGIN_EXPORT latex
\usetikzlibrary{decorations.pathreplacing}
\begin{center}
\begin{tikzpicture}
\node (a) at (0,0){
  \begin{tabular}{ | l | c | c | r |}
    \hline
    $Hash_{1}$ & $Hash_{2}$ & ... & $Hash_{HashSize}$ \\ \hline
  \end{tabular}
};
\node[yshift=0.1cm] (headmain) at (a.north){
Tabela de dispersão perfeita
};
\node[yshift=-2cm,xshift=-7.3cm] (b) at (a.south) 
{

  \begin{tabular}{ | l | c | c | r |}
    \hline
    $Obj_{1}$ & $Obj_{2}$ & ... & $Obj_{HashSize}$  \\ \hline
  \end{tabular}
};

\node[yshift=-2cm,xshift=-1.5cm] (c) at (a.south) 
{

  \begin{tabular}{ | l | c | c | r |}
    \hline

    $Obj_{1}$ & $Obj_{2}$ & ... & $Obj_{HashSize}$  \\ \hline
  \end{tabular}
};

\node[yshift=-2cm,xshift=1.7cm] (d) at (a.south) 
{
...
};

\node[yshift=-2cm,xshift=+5cm] (e) at (a.south) 
{
  \begin{tabular}{ | l | c | c | r |}
    \hline
    $Obj_{1}$ & $Obj_{2}$ & ... & $Obj_{HashSize}$  \\ \hline
  \end{tabular}
};
\draw[decorate,decoration={brace, amplitude=10pt, raise=5pt, mirror}]
  (b.south west) to node[black,midway,below= 15pt] {HashSize-Tabelas de dispersão} (e.south east);
\draw[->,ultra thick](a)--(b);
\draw[->,ultra thick](a)--(c);
\draw[->,ultra thick](a)--(d);
\draw[->,ultra thick](a)--(e);

\end{tikzpicture}
\end{center}
#+END_EXPORT

*** Mapa de Colisão
   O mapa de colisão foi feito para trabalhar com a colisão de maneira que ela fosse um evento ou seja, só é preciso checar caso haja alguma mudança no mapa e só ira checar colisões nas áreas de mudança oque garante uma complexidade assintótica ótima.
   Também é importante utilizá-lo para diminuir o tempo de busca pelo carro Z para ser O(1) pois caso não haja mapa de colisão com os identificadores dos veículos no mapa esse tempo de busca seria $O(n)$ em uma tabela de dispersão não perfeita.

\bigskip
Como definido na introdução o tamanho do mapa em cada dimensão é 6 e há 2 dimensões.

#+BEGIN_EXPORT latex
\begin{equation}\label{eq:MapSize}
\begin{aligned}
MapDimensions \coloneqq 2\\
MapSize \coloneqq 6
\end{aligned}
\end{equation}
#+END_EXPORT


#+BEGIN_EXPORT latex
\begin{verbatim}

Y+---+---+---+---+---+---+
6|   |   |   |   |   |   |
 +---+---+---+---+---+---+
5|   |   |   |   |   |   |
 +---+---+---+---+---+---+
4|   |   |   |   | Z | Z |
 +---+---+---+---+---+---+
3|   |   |   |   |   | A |
 +---+---+---+---+---+---+
2|   |   |   |   |   | A |
 +---+---+---+---+---+---+
1|   |   |   |   |   | A |
 +---+---+---+---+---+---+
   1   2   3   4   5   6 X
      Mapa de colisão
\end{verbatim}

#+END_EXPORT

O mapa possui funções para inserir objetos nele e ao mesmo tempo detectar colisões devido a inserções e também possui função de remoção do mapa.

#+BEGIN_SRC C
int collission_map_insert(map coll_map,object* obj);
int collission_map_remove(map coll_map,object* obj);
#+END_SRC

*** Tempo de algoritmo
   Essa é a estrutura de dados que guarda os dados relacionados a tempo do algoritmo. Capturando o tempo de usuário, tempo de sistema e o tempo total.
#+BEGIN_SRC C
  struct algorithm_time{
    double utime,stime,total_time;
  };
#+END_SRC
Há uma função auxiliar para contar o tempo, possui um parâmetro que auxilia na inicialização da contagem e na parada e outros parâmetros que guardam os dados.
#+BEGIN_SRC C
  enum {START, STOP};
  void time_count(struct rusage *resources,char start,algorithm_time *algo_time);
#+END_SRC

*** Objeto
   A estrutura de dados /Object/ descreve um objeto que é a generalização de um veículo e pode ser especificado para um veículo. Possui os atributos a seguir:
- Rótulo (Identificador)
- Posições x e y
- Tamanho
Com base na introdução será definido o menor tamanho de um objeto.
#+BEGIN_EXPORT latex
\begin{equation}\label{eq:MinObjectSize}
\begin{aligned}
MinObjectSize \coloneqq 2
\end{aligned}
\end{equation}
#+END_EXPORT

- Direção

#+BEGIN_SRC C
  struct object{
    char label,dir;
    int x,y,size;
  };
#+END_SRC

Esse tipo de dado contem as funções básicas de leitura e mudança de variáveis. Assim como um pequeno detalhe de implementação que é a normalização das coordenadas, visto que os vetores na linguagem de programação usada começam no índice 0, para se adequar a essa estrutura há uma normalização dos dados quando eles entram e quando eles saem. Ou seja internamente os objetos guardam as coordenadas com a origem em (0,0).

#+BEGIN_SRC C
int normalize_coordinate(int coord);
int normalize_coordinate_out(int coord);
#+END_SRC

#+BEGIN_EXPORT latex
\begin{center}
\begin{tikzpicture}[node distance = 2.8cm, auto]
    % Place nodes
    \node [block] (arqentrada) {Arquivos de entrada};
    \node [cloud, left of=arqentrada] (coordin) {Origem (1,1)};
    \node [block, below of=arqentrada] (simulador) {Simulador de estacionamento};
    \node [block, below of=simulador] (saida) {Saída padrão};
    % Draw edges
    \path [line,dashed] (coordin) -- (arqentrada);
    \path [line,dashed] (arqentrada) -- (simulador) node [midway, above] (TextNode) {(1,1) $\rightarrow$ (0,0)};
    \path [line,dashed] (simulador) -- (saida) node [midway, above] (TextNode) {(0,0) $\rightarrow$ (1,1)};
\end{tikzpicture}
\end{center}
#+END_EXPORT

Um /Object/ também possui uma função para se mover com base em uma direção e amplitude dada.

#+BEGIN_SRC C
void obj_move(object *obj,char dir,int amplitude);
#+END_SRC

** Entrada e saída
   Esse módulo é responsável pela maior parte das operações de entrada e saída do programa. Possui a função que irá ler os argumentos passados para o programa.
#+BEGIN_SRC C
void entry_read(int argc, char* argv[],FILE** fpc,FILE** fm);
#+END_SRC
Sendo a entrada padronizada como:
#+BEGIN_SRC sh
parking-simulator(-perfect) -c <arquivo de configuração> & -m <arquivo de manobras> & -d (DEBUG)
#+END_SRC
Este modulo também possui funções para imprimir o mapa de colisão, objetos e o tempo de algoritmo.
#+BEGIN_SRC C
void print_collission_map(map cmap);
void print_algorithm_time(const algorithm_time *ai,FILE* f);
void obj_print(object* obj);
#+END_SRC
** Lógica de configuração inicial
   A lógica de configuração inicial é feita pelo módulo /parking/.

   Essa configuração inicial colocara os objetos passados na entrada para o mapa em suas posições indicadas e direção.

   Se houver algum tipo de configuração impossível o programa irá detectar.

   Há 2 versões da lógica de configuração inicial, cada uma delas se diferenciam somente pela tabela de dispersão utilizada e como o código foi bem estruturado toda a lógica se mantem somente mudando a estrutura de dados.

   #+BEGIN_SRC C
     int parking_init(FILE* fpc,hash* objs,map coll_map);
     int parking_init_perfect(FILE* fpc,perfect_hash* objs,map coll_map);
   #+END_SRC
   Seu funcionamento poderá ser visto na secção de análise de complexidade.
** Lógica de manobras
   A lógica de manobras é feita pelo módulo /maneuvers/. 
   O processo para aplicação das manobras é ler a linha que contem uma manobra, transformar os dados em elementos computáveis, mover o objeto na direção e amplitude passada movendo passo a passo. Se ocorrer algum erro as estruturas de dados auxiliares irão detectar e é só tratar o erro. E é só repetir as mesmas instruções para cada manobra.

   Assim como a lógica de configuração inicial há 2 versões pelo mesmo motivo.
#+BEGIN_SRC C
  int apply_maneuvers(FILE* fm,hash* objs,map coll_map);
  int apply_maneuvers_perfect(FILE* fm,perfect_hash* objs,map coll_map);
#+END_SRC
   O algoritmo poderá ser visto na secção de análise de complexidade.
** Principal
   Existem 2 algoritmos principais assim também como as lógicas que fazem a utilização de todas estruturas e logicas criadas para obter a solução do problema.
 Seu algoritmo será abordado na secção de análise de complexidade.
* Análise de complexidade
  A análise de complexidade foi feita para descobrir como o algoritmo se comporta com tamanhos de entrada tendendo ao infinito, ou seja, o comportamento assintótico. O foco será a descoberta do pior caso dos algoritmos pois não haverá caso pior que o pior caso.


\bigskip
  Será feito a análise dos dois algoritmos utilizando as duas estruturas de dados diferentes, tabela de dispersão com espalhamento perfeito e tabela de dispersão com espalhamento normal.

** Tabela de dispersão comum
*** Configuração inicial do estacionamento
  Primeiro é necessário analisar as funções elementares que aparecem constantemente na resolução do problema.

  A primeira delas é o *insert_hash*, essa é a função que insere um elemento na tabela de dispersão.

#+BEGIN_EXPORT latex
\begin{algorithm}
\textbf{Input:} hash, obj
\caption{Inserir na tabela de dispersão}\label{algorithmdpsmudar}
\begin{algorithmic}[1]
\Procedure{insert\_hash}{}
	\State $position=key\_division(key,hash.size)$\Comment{O(1)}
	\For{$i = 0$ to $hash.size-1$}\Comment{O(n*max(1,1))=O(n)}
		\State $newPosition = linear\_probing(position,i,hash.size)$\Comment{O(1)}
		\If{$hash.objs[newPosition] = null$}\Comment{O(1)}
		\State $hash.objs[newPosition] = obj$
		\State \Return SUCCESS
		\EndIf
	\EndFor
	\State \Return FAIL
  \EndProcedure
\end{algorithmic}
\end{algorithm}
#+END_EXPORT

#+BEGIN_EXPORT latex
\begin{equation}\label{eq:n}
\underbrace{n}_{\parbox{1.75cm}{quantidade de elementos na tabela de dispersão}} \in \mathbb{N}\\
\end{equation}

\begin{equation}
\begin{aligned}
\eqref{eq:n}\\
insert\_hash(n)\\
\sum_{i=1}^{n} O(1)\\
n\cdot O(1)\\
O(n)\\
\therefore insert\_hash(n) \in O(n)
\end{aligned}
\end{equation}
#+END_EXPORT

A interpretação intuitiva da ordem de complexidade dessa função seria que a função é $O(n)$ no pior caso pois podem ocorrer n colisões na inserção.

A próxima função é a inserção do objeto no mapa de colisões. Que é necessária para detectar colisões.

#+BEGIN_EXPORT latex
\begin{algorithm}
\textbf{Input:} collissionMap, obj
\caption{Inserção no mapa de colisão}\label{algorithmdpsmudar}
\begin{algorithmic}[1]
\Procedure{collission\_map\_insert}{}
	\State $y = obj.y$
	\State $x = obj.x$
	\IfThenElse {$obj.direction = X$}
	{$dirIsX = 1$}
	{$dirIsX = 0$}
	\IfThenElse {$obj.direction = Y$}
	{$dirIsY = 1$}
	{$dirIsY = 0$}

	\For{$i = 0$ to $obj.size-1$}\Comment{O(obj.size*max(1,1))=O(obj.size)}
		\If{$y<collissionMap.SizeY$ \textbf{AND} $x<collissionMap.SizeX$ \textbf{AND} \\$collissionMap[y][x] = $ Empty}\Comment{O(1)}
		\State $collissionMap[y+dirIsY*i][x+dirIsX*i] = obj.label$\Comment{O(1)}
		\Else
		\State \Return FAIL
		\EndIf

	\EndFor
	\State \Return SUCCESS
  \EndProcedure
\end{algorithmic}
\end{algorithm}
#+END_EXPORT

#+BEGIN_EXPORT latex
\begin{equation}\label{eq:ObjSize}
\underbrace{ObjSize}_{\parbox{1.75cm}{ tamanho do objeto}} \in \{2,3\}\\
\end{equation}

\begin{equation}
\begin{aligned}
\eqref{eq:ObjSize}\\
collission\_map\_insert(ObjSize)\\
ObjSize\cdot O(1)\\
O(ObjSize)\\
\therefore collission\_map\_insert(ObjSize) \in O(ObjSize) \\
\end{aligned}
\end{equation}
#+END_EXPORT

É importante notar que /ObjSize/ faz parte de um conjunto finito logo ele é assintoticamente igual a $O(1)$. 

A intuição por trás disso é que existe uma constante maior que todos elementos de um conjunto finito. Ou seja pode-se observar um elemento de um conjunto finito como uma constante.

#+BEGIN_EXPORT latex
\begin{equation}\label{eq:ObjSizeO1}
\begin{aligned}
\exists (c \in \mathbb{N^{*}}) \forall ObjSize \mid ObjSize \leq c\\
c = max(ObjSize)\\
ObjSize\leq max(ObjSize)\\
\therefore collission\_map\_insert(ObjSize) \in O(1) \\
\end{aligned}
\end{equation}
#+END_EXPORT

Já com essas duas funções analisadas pode-se analisar a função *parking_init* que é a função que realiza as instruções contidas no arquivo de configuração inicial do estacionamento.

#+BEGIN_EXPORT latex
\begin{algorithm}
\textbf{Input:} fpc(File parking config), objs, collissionMap 
\caption{Configuração inicial do estacionamento}\label{algorithmdpsmudar}
\begin{algorithmic}[1]
\Procedure{parking\_init}{}
\While{NOT EndOfFile(fpc)}\Comment{Objs*(O(n)+O(ObjSize))}
\State $scanFileLine(fpc,label,size,dir,x,y)$\Comment{O(1)}
\State $obj = new\_obj(label,size,dir,x,y)$\Comment{O(1)}
\If{$insert\_hash(objs,obj) = $ FAIL}\Comment{O(n)}
\State \Return FAIL
\EndIf
\If{$collission\_map\_insert(collissionMap,obj) = $ FAIL}\Comment{O(ObjSize)}
\State \Return FAIL
\EndIf
\EndWhile
\State \Return SUCCESS
\EndProcedure
\end{algorithmic}
\end{algorithm}
#+END_EXPORT


Como dito na especificação do problema o número de objetos são limitados, visto que o mapa foi definido como 6x6=36 e o menor objeto é de tamanho 2 logo so cabem 18 objetos no mapa no máximo, esse conjunto de 0 a 18 objetos pode ser visto como uma constante.

Seja /Objs/ a quantidade de objetos (especificados no arquivo de configuração inicial).

#+BEGIN_EXPORT latex
\begin{equation}\label{eq:Objs}
\begin{aligned}
\underbrace{Objs}_{\parbox{1.75cm}{ quantidade de objetos}}\in \mathbb{N}\\
\eqref{eq:MapSize} Objs \in \{x : x \in \mathbb{N} \land (0 \leq x \leq MapSize^{MapDimensions}\div MinObjectSize)\}\\
Objs \in \{x : x \in \mathbb{N} \land (0 \leq x \leq 18)\}\\
\exists (c \in \mathbb{N^{*}}) \forall Objs \mid Objs \leq c\\
c = max(Objs)\\
Objs \leq max(Objs)\\
Objs \in O(1)
\end{aligned}
\end{equation}

\begin{equation}\label{eq:nObjs}
\begin{aligned}
i \in \{x : x \in \mathbb{N^{*}} \land  x \leq Objs\}\\
n = Objs-i\\
\exists (c \in \mathbb{N^{*}}) \exists (m \in \mathbb{N^{*}}) \forall (Objs \geq m)\\
0 \leq n \leq c\cdot Objs\\
0 \leq Objs-i \leq c\cdot Objs\\
m = 1; c = 1\\
0 \leq Objs-i \leq Objs\\
Objs-i \in O(Objs)\\
n \in O(Objs)\\
\eqref{eq:Objs}\\
n \in O(1)\\
\end{aligned}
\end{equation}

\begin{equation}\label{eq:parkinginit}
\begin{aligned}
parking\_init(Objs,ObjSize)\\
\sum_{i=1}^{Objs} (O(n)+O(ObjSize))\\
\eqref{eq:ObjSizeO1} \implies \sum_{i=1}^{Objs} O(max(n,1))\\
\sum_{i=1}^{Objs} O(n)\\
\eqref{eq:nObjs} \sum_{i=1}^{Objs} O(Objs) = Objs\cdot O(Objs) = O(Objs^2)\\
\therefore parking\_init(Objs,ObjSize) \in O(Objs^{2})\\
\therefore parking\_init(Objs,ObjSize) \in O(1)\\
\end{aligned}
\end{equation}

\bigskip

#+END_EXPORT
 

*** Aplicação das manobras

Do mesmo modo que foi feito para configuração inicial deverá ser feito para a aplicação das manobras, será analisado primeiro as funções elementares.

A primeira função será a *search_hash*, ela será necessária para fazer a busca pelo rotulo do objeto. Isso será utilizado a cada manobra a ser executada, pois é necessário saber o objeto que corresponde a cada rotulo para realizar a manobra.

#+BEGIN_EXPORT latex
\begin{algorithm}
\textbf{Input:} hash, label
\caption{Busca objeto em uma tabela de dispersão}\label{algorithmdpsmudar}
\begin{algorithmic}[1]
\Procedure{search\_hash}{}
	\State $position=key\_division(key,hash.size)$\Comment{O(1)}
	\For{$i = 0$ to $hash.size-1$}\Comment{O(n*max(1,1,1))=O(n)}
		\State $newPosition = linear\_probing(position,i,hash.size)$\Comment{O(1)}
		\If{$exist(hash.objs[newPosition]) = $FALSE}\Comment{O(1)}
		\State \Return FAIL
		\EndIf
		\If{$hash.objs[newPosition].label = label$}\Comment{O(1)}
		\State \Return $hash.objs[newPosition]$
		\EndIf
	\EndFor
	\State \Return FAIL
\EndProcedure
\end{algorithmic}
\end{algorithm}
#+END_EXPORT

#+BEGIN_EXPORT latex
\begin{equation}
\begin{aligned}
\eqref{eq:n}\\
search\_hash(n)=\\
\sum_{i=1}^{n} O(1)=\\
n\cdot O(1)=\\
O(n)\\
\therefore search\_hash(n) \in O(n)
\end{aligned}
\end{equation}
#+END_EXPORT

Além da inserção também será necessário a remoção do objeto do mapa de colisão para simular um movimento do mesmo.

#+BEGIN_EXPORT latex
\begin{algorithm}
\textbf{Input:} collissionMap, obj
\caption{Remoção no mapa de colisão}\label{algorithmdpsmudar}
\begin{algorithmic}[1]
\Procedure{collission\_map\_remove}{}
	\State $y = obj.y$
	\State $x = obj.x$
	\IfThenElse {$obj.direction = X$}
	{$dirIsX = 1$}
	{$dirIsX = 0$}
	\IfThenElse {$obj.direction = Y$}
	{$dirIsY = 1$}
	{$dirIsY = 0$}

	\For{$i = 0$ to $obj.size-1$}\Comment{O(ObjSize*max(1,1,1))=O(ObjSize)}
		\If{$y<collissionMap.SizeY$ \textbf{AND} $x<collissionMap.SizeX$}\Comment{O(1)}
		\If{$collissionMap[y][x] \neq$ Empty}\Comment{O(1)}
		\State $collissionMap[y+dirIsY*i][x+dirIsX*i] =$ Empty\Comment{O(1)}
		\EndIf
		\Else
		\State \Return FAIL
		\EndIf

	\EndFor
  \EndProcedure
\end{algorithmic}
\end{algorithm}
#+END_EXPORT

#+BEGIN_EXPORT latex
\begin{equation}
\begin{aligned}
\eqref{eq:ObjSize}\\
collission\_map\_remove(ObjSize)\\
ObjSize\cdot O(1) = O(ObjSize)\\
\therefore collission\_map\_remove(ObjSize) \in O(ObjSize) \\
\eqref{eq:ObjSizeO1} \therefore collission\_map\_remove(ObjSize) \in O(1) \\
\end{aligned}
\end{equation}
#+END_EXPORT

Com essas funções analisadas já é possível analisar a função *apply_maneuvers* (função que aplica as manobras).

#+BEGIN_EXPORT latex
\begin{algorithm}
\textbf{Input:} fm(File maneuvers), objs, collissionMap
\caption{Aplicação das manobras}\label{algorithmdpsmudar}
\begin{algorithmic}[1]
\Procedure{apply\_maneuvers}{}
\While{NOT EndOfFile(fm)}\Comment{O(maneuvers*n)}
      \State $scanFileLine(fm,label,direction,amplitude)$\Comment{O(1)}
      \State $currentObj = search\_hash(objs,label)$\Comment{O(n)=O(Objs)}
      \State $sense = amplitude/absoluteValue(amplitude)$\Comment{O(1)}
      \State $amplitude = absoluteValue(amplitude)$\Comment{O(1)}
      \For{i = 0 to amplitude-1}\Comment{O(amplitude*max(ObjSize,1,ObjSize))=O(amplitude*ObjSize)=O(1)}
      \State $collission\_map\_remove(collissionMap,currentObj)$\Comment{O(ObjSize)}
      \State $obj\_move(currentObj,direction,currentObj)$\Comment{O(1)}
      \If{$collission\_map\_insert(collissionMap,currentObj)$ = FAIL}\Comment{O(ObjSize)}
      \State \Return FAIL
      \EndIf
      \EndFor
\EndWhile
\EndProcedure
\end{algorithmic}
\end{algorithm}
#+END_EXPORT

Seja /maneuvers/ a quantidade de manobras e /amplitude/ a amplitude do movimento.

#+BEGIN_EXPORT latex
\begin{equation}\label{eq:maneuvers}
\underbrace{maneuvers}_{\parbox{1.75cm}{ quantidade de manobras}}\in \mathbb{N}\\
\end{equation}
\begin{equation}\label{eq:amplitude}
\underbrace{amplitude}_{\parbox{1.75cm}{ amplitude do movimento}}\in \{x : x \in \mathbb{N} \land (0 \leq x < MapSize)\};\\
amplitude \in O(1)\\
\end{equation}
\begin{equation}
\begin{aligned}
\eqref{eq:maneuvers}\\
\eqref{eq:amplitude}\\
apply\_maneuvers(maneuvers,amplitude,ObjSize,Objs)\\
maneuvers\cdot (O(amplitude\cdot max(ObjSize,1,ObjSize))+O(n))\\
maneuvers\cdot (O(amplitude\cdot ObjSize)+O(n))\\
maneuvers\cdot (O(1)+O(Objs))\\
maneuvers\cdot O(Objs)\\
O(maneuvers\cdot Objs)\\
\therefore apply\_maneuvers(maneuvers,amplitude,ObjSize,Objs) \in O(maneuvers\cdot Objs)\\
\eqref{eq:Objs}\\
\therefore apply\_maneuvers(maneuvers,amplitude,ObjSize,Objs) \in O(maneuvers)\\
\end{aligned}
\end{equation}
#+END_EXPORT

É importante deixar um fato explicitado, as funções *parking_init* e *apply_maneuvers* foram explicitadas com duas ordens de complexidade na conclusão da análise, mesmo que tenha chegado nessas complexidades a escolha foi que será priorizado a complexidade que contem o termo /Objs/, pois sem isso não seria deixado explicito que existe um termo que representa a colisão da tabela de dispersão.

E além disso com o termo explicitado se o tamanho do mapa pudesse variar a analise de complexidade trataria esse caso também, logo quando a analise contem o termo /Objs/ ela é mais generalista. Ou seja, quando possível será preservado o termo /Objs/.

*** Principal
Com as principais funções que o programa principal chama analisadas só falta analisar o programa principal. 

#+BEGIN_EXPORT latex
\begin{algorithm}
\textbf{Input:} fpc,fm\Comment{Arquivo de configuração inicial e manobra}
\caption{Algoritmo principal}\label{algorithmdpsmudar}
\begin{algorithmic}[1]
\Procedure{parking\_simulator}{}
\State $collissionMap = init\_map()$\Comment{O(1)}
\State $fpcLines = file\_lines(fpc)$\Comment{O(1)}
\State $objs = new\_hash(fpcLines)$\Comment{O(Objs)}
\State $time\_count(START,algoTime)$\Comment{O(1)}
\If{$parking\_init(fpc,objs,collissionMap)$}\Comment{O($Objs^{2}$)}
\State $apply\_maneuvers(fm,objs,collissionMap)$\Comment{O($maneuvers\cdot Objs$)}
\State $time\_count(STOP,algoTime)$\Comment{O(1)}
\State $print\_algorithm\_time(algoTime,stdout)$\Comment{O(1)}
\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}
#+END_EXPORT

#+BEGIN_EXPORT latex
\begin{equation}
\begin{aligned}
\eqref{eq:n}\\
parking\_simulator(Objs,maneuvers)\\
O(max(Objs,Objs^{2},maneuvers\cdot Objs))\\
O(max(1,1,maneuvers\cdot Objs))\\
O(maneuvers\cdot Objs)\\
\therefore parking\_simulator(Objs,maneuvers) \in O(maneuvers\cdot Objs)\\
\therefore parking\_simulator(Objs,maneuvers) \in O(maneuvers)\\
\end{aligned}
\end{equation}
#+END_EXPORT

** Tabela de dispersão com espalhamento perfeito
*** Configuração inicial do estacionamento
   Agora para a tabela dispersão as coisas que irão mudar serão as funções da tabela. A inserção será a primeira delas abordada. Agora como não há colisão o índice dado é absoluto e todas operações serão $O(1)$ como será mostrado a seguir.
   


#+BEGIN_EXPORT latex
\begin{algorithm}
\textbf{Input:} hash, obj
\caption{Inserir na tabela de dispersão com espalhamento perfeito}\label{algorithmdpsmudar}
\begin{algorithmic}[1]
\Procedure{insert\_perfect\_hash}{}\Comment{O(max(1,1,1,1)) = O(1)}
\State $hash\_index = hash\_division(obj.label,HashSize)$\Comment{\eqref{eq:HashSize} O(1)}
\State $obj\_index = key\_division(obj.label,HashSize)$\Comment{O(1)}
\State $hash.hashs[hash\_index].objs[obj\_index] = obj$\Comment{O(1)}
\State \Return SUCCESS\Comment{O(1)}
\EndProcedure
\end{algorithmic}
\end{algorithm}
#+END_EXPORT

#+BEGIN_EXPORT latex
\begin{equation}
\begin{aligned}
insert\_perfect\_hash(n)\\
O(max(1,1,1,1))\\
\therefore insert\_perfect\_hash(n) \in O(1)
\end{aligned}
\end{equation}
#+END_EXPORT

Pela matemática feita pode-se observar que o custo de utilizar a função de inserção não muda com a quantidade de elementos na tabela.

#+BEGIN_EXPORT latex
\begin{algorithm}
\textbf{Input:} fpc(File parking config), objs,collissionMap
\caption{Configuração inicial do estacionamento utilizando espalhamento perfeito}\label{algorithmdpsmudar}
\begin{algorithmic}[1]
\Procedure{parking\_init\_perfect}{}
\While{NOT EndOfFile(fpc)}\Comment{O(Objs*max(1,ObjSize)) = O(Objs)}
\State $scanFileLine(fpc,label,size,dir,x,y)$\Comment{O(1)}
\State $obj = new\_obj(label,size,dir,x,y)$\Comment{O(1)}
\If{$insert\_perfect\_hash(objs,obj) = $ FAIL}\Comment{O(1)}
\State \Return FAIL
\EndIf
\If{$collission\_map\_insert(collissionMap,obj) = $ FAIL}\Comment{O(ObjSize)=O(1)}
\State \Return FAIL
\EndIf
\EndWhile
\State \Return SUCCESS
\EndProcedure
\end{algorithmic}
\end{algorithm}
#+END_EXPORT

#+BEGIN_EXPORT latex
\begin{equation}
\begin{aligned}
\eqref{eq:Objs}\\
parking\_init\_perfect(Objs,ObjSize)\\
\sum_{i=1}^{Objs} (O(1)+O(ObjSize))\\
\eqref{eq:ObjSizeO1}\\
\sum_{i=1}^{Objs} O(1)\\
Objs\cdot O(1)\\
O(Objs)\\
\therefore parking\_init\_perfect(Objs,ObjSize)\in O(Objs)\\
\therefore parking\_init\_perfect(Objs,ObjSize)\in O(1)\\
\end{aligned}
\end{equation}
#+END_EXPORT

*** Aplicação das manobras
Agora na busca será a mesma coisa.

#+BEGIN_EXPORT latex
\begin{algorithm}
\textbf{Input:} hash, obj
\caption{Buscar na tabela de dispersão com espalhamento perfeito}\label{algorithmdpsmudar}
\begin{algorithmic}[1]
\Procedure{search\_perfect\_hash}{}\Comment{O(max(1,1,1)) = O(1)}
\State $hash\_index = hash\_division(obj.label,HashSize)$\Comment{O(1)}
\State $obj\_index = key\_division(obj.label,HashSize)$\Comment{O(1)}
\State \Return $hash.hashs[hash\_index].objs[obj\_index]$\Comment{O(1)}
\EndProcedure
\end{algorithmic}
\end{algorithm}
#+END_EXPORT

#+BEGIN_EXPORT latex
\begin{equation}
\begin{aligned}
search\_perfect\_hash(n)\\
O(max(1,1,1))\\
O(1)\\
\therefore search\_perfect\_hash(n) \in O(1)
\end{aligned}
\end{equation}
#+END_EXPORT


#+BEGIN_EXPORT latex
\begin{algorithm}
\textbf{Input:} fm(File maneuvers), objs, collissionMap
\caption{Aplicação das manobras utilizando espalhamento perfeito}\label{algorithmdpsmudar}
\begin{algorithmic}[1]
\Procedure{apply\_maneuvers\_perfect}{}
\While{NOT EndOfFile(fm)}\Comment{O(maneuvers*1) = O(maneuvers)}
      \State $scanFileLine(fm,label,direction,amplitude)$\Comment{O(1)}
      \State $currentObj = search\_perfect\_hash(objs,label)$\Comment{O(1)}
      \State $sense = amplitude/absoluteValue(amplitude)$\Comment{O(1)}
      \State $amplitude = absoluteValue(amplitude)$\Comment{O(1)}
      \For{i = 0 to amplitude-1}\Comment{O(amplitude*max(ObjSize,1,ObjSize))=O(amplitude*ObjSize)=O(1)}
      \State $collission\_map\_remove(collissionMap,currentObj)$\Comment{O(ObjSize) = O(1)}
      \State $obj\_move(currentObj,direction,currentObj)$\Comment{O(1)}
      \If{$collission\_map\_insert(collissionMap,currentObj)$ = FAIL}\Comment{O(ObjSize) = O(1)}
      \State \Return FAIL
      \EndIf
      \EndFor
\EndWhile
\EndProcedure
\end{algorithmic}
\end{algorithm}
#+END_EXPORT


#+BEGIN_EXPORT latex
\begin{equation}
\begin{aligned}
\eqref{eq:maneuvers}\\
\eqref{eq:amplitude}\\
apply\_maneuvers\_perfect(maneuvers,amplitude,ObjSize)\\
maneuvers\cdot (O(amplitude\cdot max(ObjSize,1,ObjSize))+O(1))\\
maneuvers\cdot (O(amplitude\cdot ObjSize)+O(1))\\
maneuvers\cdot (O(1)+O(1))\\
O(maneuvers)\\
\therefore apply\_maneuvers\_perfect(maneuvers,amplitude,ObjSize) \in O(maneuvers)\\
\end{aligned}
\end{equation}
#+END_EXPORT


*** Principal
Com as principais funções que o programa principal chama analisadas so falta analisar o programa principal. 

#+BEGIN_EXPORT latex
\begin{algorithm}
\textbf{Input:} fpc,fm\Comment{Arquivo de configuração inicial e manobra}
\caption{Algoritmo principal com espalhamento perfeito}\label{algorithmdpsmudar}
\begin{algorithmic}[1]
\Procedure{parking\_simulator\_perfect}{}
\State $collissionMap = init\_map()$\Comment{O(1)}
\State $fpcLines = file\_lines(fpc)$\Comment{O(1)}
\State $objs = new\_hash(HashSize)$\Comment{\eqref{eq:HashSize} O(1)}
\State $time\_count(START,algoTime)$\Comment{O(1)}
\If{$parking\_init\_perfect(fpc,objs,collissionMap)$}\Comment{O($Objs$)}
\State $apply\_maneuvers\_perfect(fm,objs,collissionMap)$\Comment{O($maneuvers$)}
\State $time\_count(STOP,algoTime)$\Comment{O(1)}
\State $print\_algorithm\_time(algoTime,stdout)$\Comment{O(1)}
\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}
#+END_EXPORT

#+BEGIN_EXPORT latex
\begin{equation}
\begin{aligned}
\eqref{eq:n}\\
parking\_simulator\_perfect(Objs,maneuvers)\\
O(max(Objs,maneuvers))\\
\eqref{eq:Objs}\\
O(maneuvers)\\
\therefore parking\_simulator\_perfect(Objs,maneuvers) \in O(maneuvers)\\
\end{aligned}
\end{equation}
#+END_EXPORT



** Conclusão
   Foi possível observar que os dois algoritmos possuem a mesma complexidade assintótica, porém especificamente para esse problema pois o mapa não cresce o que implica em uma quantidade limitada de veículos e também pelo formato do rótulo dos veículos há uma limitação na sua quantidade também.

   Devido a isto até mesmo as funções relacionadas a tabela de dispersão comum foram mostradas com duas conclusões de ordem de complexidade, uma que compreende o problema generalista e outra o problema especifico que é o feito neste trabalho.

   Logo a diferenciação da complexidade dos dois algoritmos se daria por meio da procura pela função de complexidade, como esse é um processo complicado e depende de muitos fatores logo será feito uma abordagem mais simplificada na seção de resultados, será feito regressões lineares para achar os fatores da função.


* Testes
Para saber se o algoritmo funciona como o esperado foi feito os testes dos possíveis erros. Os erros detectados como fundamentais do problema são os apresentados seguir.

** Finalização
Dado como configuração inicial do estacionamento:
#+begin_src text
Z 2 X X5Y5
#+end_src

e o arquivo de manobras sendo:

#+begin_src text
Z Y -1
#+end_src

A saída é:

#+BEGIN_SRC shell :results output :exports results :eval no
cd ..
./parking-simulator -c testes/objs1.txt -m testes/man1.txt
#+END_SRC

#+RESULTS:
: Z Reached the end! Y 4 X 6
: User time 0.000048s, System time 0.000000s, Total Time 0.000048s

Saída correta.

** Colisão
Dado como configuração inicial do estacionamento:

#+begin_src text
Z 2 X X5Y5
T 2 X X4Y6
#+end_src

e o arquivo de manobras sendo:

#+begin_src text
Z Y 1
#+end_src

Espera-se que colida.

A saída é:

#+BEGIN_SRC shell :results output :exports results :eval no
      cd ..
      ./parking-simulator -c testes/objs2.txt -m testes/man2.txt 2>&1
#+END_SRC

#+RESULTS:
: Collission happened
: Failed in maneuvers apply.
: User time 0.000044s, System time 0.000000s, Total Time 0.000044s

Saída correta.

** Posição fora do mapa
Dado como configuração inicial do estacionamento:

#+begin_src text
Z 2 X X5Y5
T 2 X X4Y6
R 2 X X2Y3
#+end_src



e o arquivo de manobras sendo:

#+begin_src text
Z X 1
#+end_src

Espera-se que saia do mapa (ou colida, que é a palavra utilizada na saída de erro).

A saída é:

#+BEGIN_SRC shell :results output :exports results :eval no
      cd ..
      ./parking-simulator -c testes/objs3.txt -m testes/man3.txt 2>&1
#+END_SRC

#+RESULTS:
: Collission happened
: Failed in maneuvers apply.
: User time 0.000043s, System time 0.000000s, Total Time 0.000043s

Saída correta.

** Inicialização com colisão
Dado como configuração inicial do estacionamento:

#+begin_src text
Z 2 Y X5Y5
T 2 X X4Y6
R 2 X X2Y3
A 2 Y X1Y5
#+end_src

e o arquivo de manobras sendo:

#+begin_src text
Z X 0
#+end_src

Espera-se que colida:

#+BEGIN_SRC shell :results output :exports results :eval no
      cd ..
      ./parking-simulator -c testes/objs4.txt -m testes/man4.txt 2>&1
#+END_SRC

#+RESULTS:
: Collission happened in parking configuration file. Objects in same position.
: Error in config file.

Saída correta.

** Desalocação de memória
   Foi feito o teste de vazamento de memória com o programa com erros e sem erros, com a utilização de um programa chamado /valgrind/ que detecta blocos  de memória não desalocados, e todos deram como resultado que todos blocos de memória alocados foram desalocados.
   #+BEGIN_SRC text
==12259== Memcheck, a memory error detector
==12259== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==12259== Using Valgrind-3.14.0.GIT and LibVEX; rerun with -h for copyright info
==12259== Command: ./parking-simulator -c testes/objs4.txt -m testes/man4.txt
==12259== 
==12259== 
==12259== HEAP SUMMARY:
==12259==     in use at exit: 0 bytes in 0 blocks
==12259==   total heap usage: 17 allocs, 17 frees, 5,548 bytes allocated
==12259== 
==12259== All heap blocks were freed -- no leaks are possible
==12259== 
==12259== For counts of detected and suppressed errors, rerun with: -v
==12259== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
   #+END_SRC
* Resultados

Os resultados foram obtidos utilizando alguns algoritmos auxiliares em /shell script/. (veja o Apêndice) 
** Manobras
Foi gerado o gráfico com regressão linear a seguir do algoritmo com espalhamento normal e espalhamento perfeito, do tempo total. (Figuras ref:fig:normal-data-total e ref:fig:perfect-data-total)

#+BEGIN_SRC R :results output graphics :file normal-data-gg.png :exports results
normalData <- read.table("../data/normal-data.txt")
#perfectData <- read.table("data/perfect-data.txt")
names(normalData) <- c("Time", "Type","Objects","Maneuvers")
#names(perfectData) <- c("Time", "Type","Objects","Maneuvers")
normalData<- subset(normalData,Type=="total")
#perfectData<- subset(perfectData,Type=="total")

ObjectSizes<-unique(normalData$Objects)
print(length(ObjectSizes))
require(ggplot2)
require(ggpmisc)
p<-qplot(x=Maneuvers,xlab="Manobras",y=Time,ylab="Tempo(s)",data=normalData,color=Objects)+geom_point()+scale_color_gradient(low='#05D9F6', high='#5011D1')
# annotate("text", x = 750000, y = 0.25, label = "Espalhamento com complexidade linear",angle=35)
p + labs(color = "Objetos") + geom_smooth(method='lm',formula=y~x,col='red')+stat_poly_eq(formula=y~x, aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), parse = TRUE)
#+END_SRC
#+CAPTION: Tempo total do algoritmo com espalhamento normal.label:fig:normal-data-total
#+ATTR_LATEX: :width 0.5\textwidth
#+RESULTS:
[[file:normal-data-gg.png]]

#+BEGIN_SRC R :results output graphics :file perfect-data-gg.png :exports results
  perfectData <- read.table("../data/perfect-data.txt")
  names(perfectData) <- c("Time", "Type","Objects","Maneuvers")
  perfectData<- subset(perfectData,Type=="total")

  ObjectSizes<-unique(perfectData$Objects)
  print(length(ObjectSizes))
  require(ggplot2)

  require(ggpmisc)
  p<-qplot(x=Maneuvers,xlab="Manobras",y=Time,ylab="Tempo(s)",data=perfectData,color=Objects)+geom_point()+scale_color_gradient(low='#05D9F6', high='#5011D1')
# annotate("text", x = 750000, y = 0.25, label = "Espalhamento com complexidade linear",angle=35)
  p + labs(color = "Objetos") + geom_smooth(method='lm',formula=y~x,col='red')+stat_poly_eq(formula=y~x, aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), parse = TRUE)
#+END_SRC

#+CAPTION: Tempo total do algoritmo com espalhamento perfeito.label:fig:perfect-data-total
#+ATTR_LATEX: :width 0.5\textwidth
#+RESULTS:
[[file:perfect-data-gg.png]]

É possível ver que a complexidade calculada foi comprovada, os gráficos mostram uma complexidade linear.

Pode-se notar que o espalhamento perfeito possui alguns fatores na equação linear que demonstram ser um pouco mais rápido, porém esse valor é muito pequeno. Isso demonstra que a tabela de dispersão normal possivelmente está na média colidindo muito pouco.

Ou seja por causa da limitação de objetos no mapa o algoritmo com espalhamento perfeito e espalhamento normal se diferenciam por uma constante.

\bigskip
Veja uma simples média de tempo dos dados com 100000 manobras.
  #+ATTR_LATEX: :align |c|c|
|---------------------+-----------------------|
| Espalhamento normal | Espalhamento perfeito |
|---------------------+-----------------------|
| 0.04566633s         | 0.04402262s           |
|---------------------+-----------------------|

#+BEGIN_SRC R :results output :exports results :eval no
    Data <- read.table("../data/normal-data.txt")
    names(Data) <- c("Time", "Type","Objects","Maneuvers")
    ManeuversSize<- 100000
    Data<- subset(Data,Type=="total")
    Data<- subset(Data,Maneuvers==ManeuversSize)
    Data<- subset(Data, select = -c(Type,Objects,Maneuvers))
  printf <- function(...) cat(sprintf(...))
    printf("%.8fs",sapply(Data, mean, na.rm=TRUE))

#+END_SRC

#+BEGIN_SRC R :results output :exports results :eval no
  perfectData <- read.table("../data/perfect-data.txt")
  names(perfectData) <- c("Time", "Type","Objects","Maneuvers")
  ManeuversSize<- 100000
  perfectData<- subset(perfectData,Type=="total")
  perfectData<- subset(perfectData,Maneuvers==ManeuversSize)
  perfectData<- subset(perfectData, select = -c(Type,Objects,Maneuvers))
  printf <- function(...) cat(sprintf(...))
    printf("%.8fs",sapply(perfectData, mean, na.rm=TRUE))
#+END_SRC

É possível notar que o espalhamento perfeito na média para muitas manobras possui execução mais rápida.

Será analisado se isso se mantém para quantidades menores de manobra, especificamente 1000 manobras.

  #+ATTR_LATEX: :align |c|c|
|---------------------+-----------------------|
| Espalhamento normal | Espalhamento perfeito |
|---------------------+-----------------------|
| 0.00013292s         | 0.00012228s           |
|---------------------+-----------------------|

#+BEGIN_SRC R :results output :exports results :eval no
  perfectData <- read.table("../data/normal-data.txt")
  names(perfectData) <- c("Time", "Type","Objects","Maneuvers")
  ManeuversSize<- 100
  perfectData<- subset(perfectData,Type=="total")
  perfectData<- subset(perfectData,Maneuvers==ManeuversSize)
  perfectData<- subset(perfectData, select = -c(Type,Objects,Maneuvers))
  printf <- function(...) cat(sprintf(...))
    printf("%.8fs",sapply(perfectData, mean, na.rm=TRUE))
#+END_SRC

#+BEGIN_SRC R :results output :exports results :eval no
  perfectData <- read.table("../data/perfect-data.txt")
  names(perfectData) <- c("Time", "Type","Objects","Maneuvers")
  ManeuversSize<- 100
  perfectData<- subset(perfectData,Type=="total")
  perfectData<- subset(perfectData,Maneuvers==ManeuversSize)
  perfectData<- subset(perfectData, select = -c(Type,Objects,Maneuvers))
  printf <- function(...) cat(sprintf(...))
    printf("%.8fs",sapply(perfectData, mean, na.rm=TRUE))
#+END_SRC

Pelo visto o espalhamento perfeito esta conseguindo tempos menores, então só falta uma visão geral dessas médias e intervalo de confiança das mesmas. Observe na figura ref:fig:means-data.

#+BEGIN_SRC R :results output graphics :file means-data.png :exports results

library(gplots)
Data <- read.table("../data/normal-data.txt")
perfectData <- read.table("../data/perfect-data.txt")
names(Data) <- c("Time", "Type","Objects","Maneuvers")
names(perfectData) <- c("Time", "Type","Objects","Maneuvers")

ObjsSize<-10
ManeuversSize<- 100000
Data<- subset(Data,Type=="total")
Data<- subset(Data,Objects==ObjsSize)
Data<- subset(Data,Maneuvers %% 1000 == 0)

perfectData<- subset(perfectData,Type=="total")
perfectData<- subset(perfectData,Objects==ObjsSize)
perfectData<- subset(perfectData,Maneuvers %% 1000 == 0)

plotmeans(Time ~ Maneuvers, data = Data, frame = FALSE,col='forestgreen',xlab="Manobras",ylab="Tempo(s)",barcol='darkgreen',n.label=FALSE)
plotmeans(Time ~ Maneuvers, data = perfectData, frame = FALSE,add=TRUE,col='blue',barcol='blue4',n.label=FALSE)

legend("top", c("Espalhamento perfeito", "Espalhamento normal"), col=c("blue", "forestgreen"), pch=21, cex = 0.7,)
#+END_SRC

#+CAPTION: Média dos tempos dos algoritmos.label:fig:means-data
#+ATTR_LATEX: :width 0.52\textwidth
#+RESULTS:
[[file:means-data.png]]


O gráfico mostra que o programa com espalhamento perfeito na maioria das vezes tem uma média de tempo menor que o programa com espalhamento normal.

Para um conjunto menor de manobras fica evidente que uma domina a outra por uma constante. (Figura ref:fig:means-obj-100-data)



#+BEGIN_SRC R :results output graphics :file means-obj-100-data.png :exports results

library(gplots)
Data <- read.table("../data/normal-data.txt")
perfectData <- read.table("../data/perfect-data.txt")
names(Data) <- c("Time", "Type","Objects","Maneuvers")
names(perfectData) <- c("Time", "Type","Objects","Maneuvers")
man <- 100
Data<- subset(Data,Type=="total")
Data<- subset(Data,Maneuvers <= man)
perfectData<- subset(perfectData,Type=="total")
perfectData<- subset(perfectData,Maneuvers <= man)

plotmeans(Time ~ Maneuvers, data = Data, frame = FALSE,col='forestgreen',xlab="Manobras",ylab="Tempo(s)",barcol='darkgreen',n.label=FALSE)
plotmeans(Time ~ Maneuvers, data = perfectData, frame = FALSE,add=TRUE,col='blue',barcol='blue4',n.label=FALSE)
#abline(h=c(100), col= "blue", lty= 2)
abline(lm(Time ~ Maneuvers, data= Data),col='green')
abline(lm(Time ~ Maneuvers, data= perfectData),col='blue')
legend("top", c("Espalhamento perfeito", "Espalhamento normal"), col=c("blue", "forestgreen"), pch=21, cex = 0.7)
#+END_SRC

#+CAPTION: Média dos tempos com pequena quantidade de manobras.label:fig:means-obj-100-data
#+ATTR_LATEX: :width 0.33\textwidth
#+RESULTS:
[[file:means-obj-100-data.png]]


** Objetos
Com a análise do comportamento do custo da função com o aumento do número de manobras só falta analisar o aumento do tempo da função com base no aumento do número de objetos. (Figura ref:fig:means-data-total)

#+BEGIN_SRC R :results output graphics :file means-obj-data.png :exports results
  library(gplots)
  Data <- read.table("../data/normal-data.txt")
  perfectData <- read.table("../data/perfect-data.txt")
  names(Data) <- c("Time", "Type","Objects","Maneuvers")
  names(perfectData) <- c("Time", "Type","Objects","Maneuvers")
  man <- 1
  Data<- subset(Data,Type=="total")
  Data<- subset(Data,Maneuvers == man)
  perfectData<- subset(perfectData,Type=="total")
  perfectData<- subset(perfectData,Maneuvers == man)

  plotmeans(Time ~ Objects, data = Data, frame = FALSE,col='forestgreen',xlab="Objetos",ylab="Tempo(s)",barcol='darkgreen',n.label=FALSE)
  plotmeans(Time ~ Objects, data = perfectData, frame = FALSE,add=TRUE,col='blue',barcol='blue4',n.label=FALSE)
					  #abline(h=c(100), col= "blue", lty= 2)
  abline(lm(Time ~ Objects, data= Data),col='green')
  abline(lm(Time ~ Objects, data= perfectData),col='blue')
  legend("top", c("Espalhamento perfeito", "Espalhamento normal"), col=c("blue", "forestgreen"), pch=21, cex = 0.7)
#+END_SRC

#+CAPTION: Média dos tempos de acordo com a quantidade de objetos, 1 manobra.label:fig:means-data-total
#+ATTR_LATEX: :width 0.43\textwidth
#+RESULTS:
[[file:means-obj-data.png]]

#+BEGIN_SRC R :results output graphics :file usr-sys-data-gg.png :exports results
  require(ggplot2)
  require(gridExtra)
  normalData <- read.table("../data/normal-data.txt")
  perfectData <- read.table("../data/perfect-data.txt")
  names(normalData) <- c("Time", "Tipo","Objects","Maneuvers")
  names(perfectData) <- c("Time", "Tipo","Objects","Maneuvers")

  normalData<- subset(normalData,Tipo!="total")
  perfectData<- subset(perfectData,Tipo!="total")

  normalData$Algoritmo <-"Espalhamento normal"
  perfectData$Algoritmo <-"Espalhamento perfeito"
  Data<- rbind(normalData,perfectData)
  ggplot(data=Data,aes(shape=Algoritmo,colour=Tipo,x=Maneuvers,y=Time))+xlab("Manobras")+geom_point()+ylab("Tempo(s)")
#+END_SRC
#+CAPTION: Tempo de usuário e sistema.label:fig:usr-sys-data
#+ATTR_LATEX: :width 0.6\textwidth :height 6cm :placement [H]
#+RESULTS:
[[file:usr-sys-data-gg.png]]

A primeira coisa que o gráfico mostra é que para um certo valor pequeno de manobras, que no caso é 1, o algoritmo com espalhamento normal ainda consegue ser mais rápido que o algoritmo com espalhamento perfeito. 

E a outra informação que pode ser obtida é que o crescimento do tempo de acordo com o crescimento da quantidade de objetos parece ser um crescimento linear para ambos algoritmos. Como a complexidade do algoritmo com espalhamento normal na iniciação do estacionamento é $O(Objs^2)$ eqref:eq:parkinginit o gráfico deveria apresentar esse comportamento, mas por causa do limite de objetos se torna inviável fazer uma regressão polinomial, ou seja a complexidade assintótica $O(1)$ também está comprovada.

** Tempo de sistema e usuário
   O tempo de usuário é o tempo associado ao tempo de processamento no modo de usuário ou fora do núcleo do sistema cite:kernel. Ou seja o tempo de usuário contém o tempo processando o código do programa e das bibliotecas que o compõe, tempos de entrada e saída por exemplo não são contabilizados.
   Já o tempo de sistema é o tempo gasto no núcleo dentro do processo ou simplesmente o tempo gasto no modo sistema no processo, já que o usuário não pode fazer todo tipo de operação possível com os recursos de um computador o núcleo do sistema é quem faz o intermédio para gerenciar as chamadas de operações privilegiadas do usuário (exemplo I/O).

   Um exemplo é se o algoritmo for recursivo as computações locais serão somadas no tempo de usuário e a chamada a função de recursão guardara todas variáveis locais atuais na pilha do sistema e quem gerencia isso é o núcleo do sistema logo somara o tempo dessa operação no tempo de sistema. Visto que não há muitas chamadas ao sistema e também principalmente não há nenhum algoritmo recursivo o tempo no modo sistema se manteve baixo como é mostrado na figura ref:fig:usr-sys-data.

* Apêndice
** Shell script para coleta de dados
   Algoritmo *data-catch*.
#+BEGIN_EXPORT latex
\begin{lstlisting}
data-catch <initial config file> <maneuvers> <execution times> <initial value> <step> <final value>
\end{lstlisting}
#+END_EXPORT

Foi utilizado o gerador de configurações iniciais para fazer mapas de 1 a 16 objetos. E a cada configuração criada era observado se o mapa conseguiria suportar um movimento de "vai e volta" de um carro em especifico, se conseguisse preserva o arquivo, se não utiliza o gerador para a quantidade de objetos em especifico.

#+BEGIN_EXPORT latex
\begin{lstlisting}
for ((i=1;i<=16;i++));do ./generator -n $i -o objs"$i".txt; done
\end{lstlisting}
#+END_EXPORT

Com os estacionamentos criados e a manobra sendo valida para todos eles então é so começar a guardar os dados com o auxiliar que foi criado acima.

#+BEGIN_EXPORT latex
\begin{lstlisting}
times=20
for ((i=1;i<=16;i++)); do ./data-catch objs"$i".txt manobras.txt $times 10000 10000 1000000; done
for ((i=1;i<=16;i++)); do ./data-catch objs"$i".txt manobras.txt $times 1 1 100; done
\end{lstlisting}
#+END_EXPORT
  
** Gerador de configurações iniciais
Foi feito um gerador de configurações iniciais. A sua utilização pode ser vista a seguir:
#+BEGIN_SRC text
generator -n <number of objects> & -o <output file>
#+END_SRC

bibliographystyle:plain
bibliography:doc.bib
